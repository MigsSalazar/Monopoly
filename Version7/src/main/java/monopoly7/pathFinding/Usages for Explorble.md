# A Guide to the Explorable Interface
So I'm rather excited by this interface as its vague declaration allows for some fun problem solving and creativity for other developers. Now clearly I have some high hopes for this interface but I realize the declaration and documentation I gave could use some work in describing the scope of what's possible with this interface. What I wrote was long and ranty but I wanted to make apparent that I want future developers (aka me and my small chimp brain) to try and think outside of the box with this interface. So down below, I want to provide a bigger, beefier set of descriptions, explanations, and examples to the docs I provided.

## Reading the Documentation
By this point, a full 5 minutes after the I first wrote the comment for the ```getReachablePoints``` method, I already hate it and know I'm going to change it so I'm gonna rewrite it here.

### The Return Value(s)
So as it is, the return value I hope to be rather straight forward. The method will return a list of Point2D.Double's that are reachable given the information passed in. Sound's simple enough. But why a list? In most board games, you have a position and a dice roll that result in one final position for that turn. So why a list? For a few reasons

 1. Many board games don't use this schema described of "old position + dice roll = new position". Games like Chess or Clue allow you to move up to the dice roll but do not require you to consume the full value of the path limit or dice roll. 
 2. Having all points available between your start and finish can be useful for game clarity as game pieces that teleport from start position to end position can be confusing for players. Having game pieces hop from space to space, like you would in a real board game such as Monopoly, helps players follow along and keep track of their own pieces which can only be done if the code knows about all positions prior to the end position.

Thus, either we need to provide a list of end positions or it's incredibly useful to have it. I'm certain there are rare cases in games where you should absolutely without a shred of a doubt only get one result from the function because of game mechanics and clarity, but in those cases, returning a list still wouldn't be bad as you could return a list of size 1. So all in all, using a List just seemed to be the best design choice as it opens the door to any and all implementations without too much additional modification or filtering of resulting end positions.

Now one last thing to note about the return value and that it can return anything of type List. That may not seem all that important but in board games, lists of positions have a way of cycling and recycling themselves so the expected logic changes. Within the util package of this project includes such a diversion in list logic with the OuroborosList and SinusoidalList. These two lists help account for repeating values in lists when the bounds of an array are exceeded. Think of Python lists where you can request indices beyond the bounds of the list and below zero to get values from the array at a different offset. The UroborosList behaves in the same way as a Python list where reaching the end will cycle you back to the beginning and requesting a value before the beginning will get you to the end. (Thus the name OuroborosList as in the Ouroboros snake) ![Ouroborus snake](https://upload.wikimedia.org/wikipedia/commons/7/71/Serpiente_alquimica.jpg) On the other end, with the SinusoidalList, these lists act more like... well... a sinusoidal function where the list, once it reaches the highest value/index, eventually returns to the lowest value/index but not before passing through every value/index in-between. In this way it can loop forever but instead of looping from head->body->tail->head->... like the UoroborosList, the SinusoidalList must traverse the body in full before reaching the head again like so: head->body->tail->reverse body->head->...

Now I understand this is a lot to say given there's only two edge cases that are infrequently used but many developers, myself included, rely on the first to last nature of lists that stop once they reach either of these end points. Board games, however, don't give a damn about easy code, and would rather implement unique and exciting game mechanics that give developers as many headaches as countries adding new date formats. The only difference is that the new game mechanics matter because they make new board games fun and interesting where as new date formats are useless because it's just politicians and bureaucrat throwing hissy fits trying to be edgy and unique.

### The Arguments
If you've already read the documentation for the arguments, then I'm sorry you have to read more. Hopefully you fully understood the documentation (/s) so to elaborate, the arguments can be used in any number of ways limited only by the imagination of the developer. Now that alone is incredibly vague so I want to give you 3 general use casses for the arguments:
 1. The Classical Coordinates
 2. The Named Use
 3. Everything Else
 
#### The Clasical Coordinates
This one is hopefully straight forward and what I expect to be fairly common if not the most common. This schema completely ignores the names and documentation by treating the arguments as individual coordinates. This is completely fine and I actually encourage it for games like Chess, Checkers, Clue, Betrayal on the House on the Hill, and any other sandbox type games where the player can move anywhere on the board given a set of limits or rules about where they can go. These rules are often mathematical in practice or radius dependent so it makes more sense to use the two arguments as coordinates from which to calculate all possible coordinates. The recommended usage for this case is to use the ```characteristic``` argument as the x coordinate and the ```point``` argument as the y coordinate. However, there is nothing stopping you from reversing this, using one argument as a flattened 2D argument and ignoring the other argument all together, or any other variant that you as the developer see fit.
#### The Named Use
Now this usage was the first that came to mind (after the classical coordinates usage) when I was trying to think up how to make this interface and is called the "Named Use" because it's what I decided to name the arguments after: "characteristic" and "point". The idea is that most board games are not simple rectangular 2D grids where coordinates can be found just by looking a the board. Many board games have regions, and islands of influence in a way.  